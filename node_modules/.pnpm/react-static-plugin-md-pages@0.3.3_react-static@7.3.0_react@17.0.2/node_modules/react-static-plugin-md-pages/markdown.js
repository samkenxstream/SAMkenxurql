"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPages = exports.getPageData = exports.getMarkdownProcessor = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _remark = _interopRequireDefault(require("remark"));

var _yaml = require("yaml");

var _mdastUtilToString = _interopRequireDefault(require("mdast-util-to-string"));

var _remarkSqueezeParagraphs = _interopRequireDefault(require("remark-squeeze-paragraphs"));

var _remarkFrontmatter = _interopRequireDefault(require("remark-frontmatter"));

var _util = require("util");

var _githubSlugger = _interopRequireDefault(require("github-slugger"));

var _glob = _interopRequireDefault(require("glob"));

var _toVfile = require("to-vfile");

var _unistUtilVisit = _interopRequireDefault(require("unist-util-visit"));

var _unistUtilSelect = require("unist-util-select");

var path = _interopRequireWildcard(require("path"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var glob = (0, _util.promisify)(_glob["default"]);
var INDEX_PAGE_RE = /^(readme|index)$/i;

var formatNameToTitle = function formatNameToTitle(title) {
  return title.split(/[\s-_]+/).map(function (x) {
    return x.replace(/^\w/, function (y) {
      return y.toUpperCase();
    });
  }).join(' ');
};

var makeGroup = function makeGroup(groupName, order) {
  return {
    key: groupName,
    children: {},
    frontmatter: {
      title: formatNameToTitle(groupName),
      order: order
    }
  };
};

var groupPages = function groupPages(pages, pathPrefix) {
  var orderOverride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var rootGroup = makeGroup(pathPrefix || '/');

  for (var i = 0, l = pages.length; i < l; i++) {
    var page = pages[i];
    var keyPath = pathPrefix ? [pathPrefix] : [];
    var groupPath = page.originalPath.split(path.sep);
    var group = rootGroup;
    var order = orderOverride;

    while (groupPath.length > 0) {
      var childGroupName = path.basename(groupPath.shift(), '.md');
      var isIndexPage = INDEX_PAGE_RE.test(childGroupName);

      if (!isIndexPage) {
        keyPath.push(childGroupName);
        order = (0, _typeof2["default"])(order) === 'object' && order[childGroupName];
        group = group.children[childGroupName] || (group.children[childGroupName] = makeGroup(childGroupName, order));
      }
    }

    group.originalPath = page.originalPath;
    group.path = keyPath.join('/');
    group.headings = page.headings;
    group.frontmatter = _objectSpread({}, group.frontmatter, {}, page.frontmatter, {
      order: typeof group.frontmatter.order === 'number' ? group.frontmatter.order : page.frontmatter.order
    });
  }

  var groupChildrenToArray = function groupChildrenToArray(group) {
    var children = Object.values(group.children).map(groupChildrenToArray);
    children.sort(function (a, b) {
      var _a$frontmatter = a.frontmatter,
          titleA = _a$frontmatter.title,
          _a$frontmatter$order = _a$frontmatter.order,
          orderA = _a$frontmatter$order === void 0 ? children.length : _a$frontmatter$order;
      var _b$frontmatter = b.frontmatter,
          titleB = _b$frontmatter.title,
          _b$frontmatter$order = _b$frontmatter.order,
          orderB = _b$frontmatter$order === void 0 ? children.length : _b$frontmatter$order;
      var order = orderA - orderB;
      return order || titleA.localeCompare(titleB);
    });
    return _objectSpread({}, group, {
      children: children
    });
  };

  return groupChildrenToArray(rootGroup);
};

var getMarkdownProcessor = function getMarkdownProcessor() {
  var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  // By default the remark parsers gets the frontmatter data and removes
  // extra-long paragraphs
  var processor = (0, _remark["default"])().use(_remarkFrontmatter["default"], ['yaml']).use(_remarkSqueezeParagraphs["default"]); // All plugins in opts.remarkPlugins will be added to remark

  plugins.forEach(function (plugin) {
    if (Array.isArray(plugin) && plugin.length > 1) {
      processor = processor.use(plugin[0], plugin[1]);
    } else {
      processor = processor.use(plugin);
    }
  });
  return processor;
};

exports.getMarkdownProcessor = getMarkdownProcessor;

var getPageData = function getPageData(tree, filename) {
  var slugger = new _githubSlugger["default"](); // Parse the frontmatter yaml data to JSON

  var yamlNode = (0, _unistUtilSelect.select)('yaml', tree);
  var frontmatter = (0, _yaml.parse)(yamlNode && yamlNode.value || '') || {}; // Find all headings and convert them to a reusable format

  var headings = (0, _unistUtilSelect.selectAll)('heading', tree).filter(function (node) {
    return node.depth <= 3;
  }).map(function (node) {
    var depth = node.depth;
    var value = depth === 1 && frontmatter.title || (0, _mdastUtilToString["default"])(node);
    var slug = slugger.slug(value);
    return {
      value: value,
      slug: slug,
      depth: depth
    };
  }); // Add fallback for Frontmatter title to first h1 heading

  var h1Node = headings.find(function (x) {
    return x.depth === 1;
  });
  frontmatter.title = frontmatter.title || h1Node && h1Node.value || formatNameToTitle(filename);
  return {
    frontmatter: frontmatter,
    headings: headings
  };
};

exports.getPageData = getPageData;

var getPages =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(location, remarkPlugins, pathPrefix, order) {
    var processor, mds, pages;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            processor = getMarkdownProcessor(remarkPlugins); // Find all markdown files in the given location

            _context2.next = 3;
            return glob('**/*.md', {
              cwd: location
            });

          case 3:
            _context2.t0 = function (x) {
              return path.normalize(path.resolve(location, x));
            };

            mds = _context2.sent.map(_context2.t0);
            _context2.next = 7;
            return Promise.all(mds.map(
            /*#__PURE__*/
            function () {
              var _ref2 = (0, _asyncToGenerator2["default"])(
              /*#__PURE__*/
              _regenerator["default"].mark(function _callee(originalPath) {
                var relative, filename, dirname, vfile, tree, _getPageData, frontmatter, headings;

                return _regenerator["default"].wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        // Reproduce the current markdown file's route path
                        relative = path.relative(location, originalPath);
                        filename = path.basename(relative, '.md');
                        dirname = path.dirname(relative); // Parse the given markdown file into MAST

                        _context.next = 5;
                        return (0, _toVfile.read)(originalPath);

                      case 5:
                        vfile = _context.sent;
                        tree = processor.parse(vfile);
                        _getPageData = getPageData(tree, filename), frontmatter = _getPageData.frontmatter, headings = _getPageData.headings;
                        return _context.abrupt("return", {
                          originalPath: path.join(dirname, filename),
                          headings: headings,
                          frontmatter: frontmatter
                        });

                      case 9:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x5) {
                return _ref2.apply(this, arguments);
              };
            }()));

          case 7:
            pages = _context2.sent;
            return _context2.abrupt("return", groupPages(pages, pathPrefix, order));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getPages(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

exports.getPages = getPages;