"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _webpack = require("webpack");

var _util = require("util");

var fs = _interopRequireWildcard(require("fs"));

var path = _interopRequireWildcard(require("path"));

var _markdown = require("./markdown");

var writeFile = (0, _util.promisify)(fs.writeFile);
var pagesFileName = 'pages.json';

var staticPluginSourceMarkdown = function staticPluginSourceMarkdown() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    getRoutes: function getRoutes(_, _ref) {
      var config = _ref.config;
      return (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var location, pagesDataFile, pages, groupToPage;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Resolve target location from ROOT folder
                location = path.resolve(config.paths.ROOT, opts.location);
                pagesDataFile = path.resolve(config.paths.ARTIFACTS, pagesFileName); // Get page data for each discovered markdown file

                _context.next = 4;
                return (0, _markdown.getPages)(location, opts.remarkPlugins, opts.pathPrefix, opts.order);

              case 4:
                pages = _context.sent;
                _context.next = 7;
                return writeFile(pagesDataFile, JSON.stringify(pages));

              case 7:
                // Convert the page tree into the react-static route structure
                groupToPage = function groupToPage(page) {
                  return {
                    path: page.key,
                    template: page.originalPath ? "".concat(path.resolve(location, page.originalPath), ".md") : undefined,
                    children: page.children.length > 0 ? page.children.map(groupToPage) : undefined
                  };
                };

                return _context.abrupt("return", [groupToPage(pages)]);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    afterGetConfig: function afterGetConfig(_ref2) {
      var config = _ref2.config;
      // Register `md` files as a valid extension with react-static
      config.extensions = [].concat((0, _toConsumableArray2["default"])(config.extensions), ['.md']);
    },
    webpack: function webpack(webpackConfig, _ref3) {
      var config = _ref3.config,
          defaultLoaders = _ref3.defaultLoaders;
      // Resolve target location and template from ROOT folder
      var location = path.resolve(config.paths.ROOT, opts.location);
      var pagesDataFile = path.resolve(config.paths.ARTIFACTS, pagesFileName);
      var defaultTemplate = path.resolve(config.paths.ROOT, opts.template); // Make the `pages` data available through a global

      webpackConfig.plugins.unshift(new _webpack.ProvidePlugin({
        __PAGES_DATA__: path.resolve(config.paths.ARTIFACTS, pagesFileName)
      })); // Create a rule that only applies to the discovered markdown files

      webpackConfig.module.rules[0].oneOf.unshift({
        test: /.md$/,
        // Limit the rule strictly to the files we have
        include: [location],
        use: [defaultLoaders.jsLoader.use[0], // The loader will parse the markdown to an MDX-compatible HAST
        // and will wrap it in the actual template given in `opts.template`
        {
          loader: require.resolve('./loader'),
          options: {
            remarkPlugins: opts.remarkPlugins,
            pathPrefix: opts.pathPrefix,
            defaultTemplate: defaultTemplate,
            location: location
          }
        }]
      });
      return webpackConfig;
    }
  };
};

var _default = staticPluginSourceMarkdown;
exports["default"] = _default;