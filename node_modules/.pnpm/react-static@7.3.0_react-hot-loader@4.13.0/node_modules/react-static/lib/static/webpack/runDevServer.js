"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = runDevServer;
exports.reloadClientData = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _webpack = _interopRequireDefault(require("webpack"));

var _chalk = _interopRequireDefault(require("chalk"));

var _socket = _interopRequireDefault(require("socket.io"));

var _webpackDevServer = _interopRequireDefault(require("webpack-dev-server"));

var _makeWebpackConfig = _interopRequireDefault(require("./makeWebpackConfig"));

var _getRouteData = _interopRequireDefault(require("../getRouteData"));

var _plugins = _interopRequireDefault(require("../plugins"));

var _utils = require("../../utils");

var _fetchSiteData = _interopRequireDefault(require("../fetchSiteData"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var devServer;
var latestState;

var buildDevRoutes = function buildDevRoutes() {};

var reloadClientData = function reloadClientData() {
  if (reloadClientData.current) {
    reloadClientData.current();
  }
}; // Starts the development server


exports.reloadClientData = reloadClientData;

function runDevServer(_x) {
  return _runDevServer.apply(this, arguments);
}

function _runDevServer() {
  _runDevServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(state) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!devServer) {
              _context.next = 7;
              break;
            }

            _context.next = 3;
            return buildDevRoutes(state);

          case 3:
            _context.next = 5;
            return reloadClientData();

          case 5:
            _context.next = 10;
            break;

          case 7:
            _context.next = 9;
            return runExpressServer(state);

          case 9:
            state = _context.sent;

          case 10:
            return _context.abrupt("return", state);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _runDevServer.apply(this, arguments);
}

function runExpressServer(_x2) {
  return _runExpressServer.apply(this, arguments);
}

function _runExpressServer() {
  _runExpressServer = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee6(state) {
    var intendedPort, port, defaultMessagePort, messagePort, messageHost, devConfig, devCompiler, devServerConfig, first, startedAt, skipLog, socket;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            // Default to localhost:3000, or use a custom combo if defined in static.config.js
            // or environment variables
            intendedPort = Number(state.config.devServer.port);
            _context6.next = 3;
            return (0, _utils.findAvailablePort)(intendedPort);

          case 3:
            port = _context6.sent;
            defaultMessagePort = 4000;

            if (process.env.REACT_STATIC_MESSAGE_SOCKET_PORT) {
              defaultMessagePort = process.env.REACT_STATIC_MESSAGE_SOCKET_PORT;
            } // Find an available port for messages, as long as it's not the devServer port


            _context6.next = 8;
            return (0, _utils.findAvailablePort)(defaultMessagePort, [port]);

          case 8:
            messagePort = _context6.sent;
            messageHost = process.env.REACT_STATIC_MESSAGE_SOCKET_HOST || 'http://localhost';

            if (intendedPort !== port) {
              console.log(_chalk["default"].red("Warning! Port ".concat(intendedPort, " is not available. Using port ").concat(_chalk["default"].green(port), " instead!")));
            }

            state = _objectSpread({}, state, {
              config: _objectSpread({}, state.config, {
                devServer: _objectSpread({}, state.config.devServer, {
                  port: port
                })
              })
            });
            devConfig = (0, _makeWebpackConfig["default"])(state);
            devCompiler = (0, _webpack["default"])(devConfig);
            devServerConfig = _objectSpread({
              contentBase: [state.config.paths.PUBLIC, state.config.paths.DIST],
              publicPath: '/',
              historyApiFallback: true,
              compress: false,
              clientLogLevel: 'warning',
              overlay: true,
              stats: 'errors-only',
              noInfo: true
            }, state.config.devServer, {
              hotOnly: true,
              proxy: _objectSpread({
                '/socket.io': {
                  target: "".concat(messageHost, ":").concat(messagePort),
                  ws: true
                }
              }, state.config.devServer ? state.config.devServer.proxy || {} : {}),
              watchOptions: _objectSpread({}, state.config.devServer ? state.config.devServer.watchOptions || {} : {}, {
                ignored: [/node_modules/].concat((0, _toConsumableArray2["default"])((state.config.devServer.watchOptions || {}).ignored || []))
              }),
              before: function before(app) {
                // Since routes may change during dev, this function can rebuild all of the config
                // routes. It also references the original config when possible, to make sure it
                // uses any up to date getData callback generated from new or replacement routes.
                buildDevRoutes =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2["default"])(
                  /*#__PURE__*/
                  _regenerator["default"].mark(function _callee4(newState) {
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return (0, _fetchSiteData["default"])(newState);

                          case 2:
                            latestState = _context4.sent;
                            app.get('/__react-static__/siteData',
                            /*#__PURE__*/
                            function () {
                              var _ref2 = (0, _asyncToGenerator2["default"])(
                              /*#__PURE__*/
                              _regenerator["default"].mark(function _callee2(req, res, next) {
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                  while (1) {
                                    switch (_context2.prev = _context2.next) {
                                      case 0:
                                        try {
                                          res.send(latestState.siteData);
                                        } catch (err) {
                                          res.status(500);
                                          res.send(err);
                                          next(err);
                                        }

                                      case 1:
                                      case "end":
                                        return _context2.stop();
                                    }
                                  }
                                }, _callee2);
                              }));

                              return function (_x4, _x5, _x6) {
                                return _ref2.apply(this, arguments);
                              };
                            }()); // Serve each routes data

                            latestState.routes.forEach(function (_ref3) {
                              var routePath = _ref3.path;
                              app.get("/__react-static__/routeInfo/".concat(encodeURI(routePath === '/' ? '' : routePath)),
                              /*#__PURE__*/
                              function () {
                                var _ref4 = (0, _asyncToGenerator2["default"])(
                                /*#__PURE__*/
                                _regenerator["default"].mark(function _callee3(req, res, next) {
                                  var route, err;
                                  return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                      switch (_context3.prev = _context3.next) {
                                        case 0:
                                          // Make sure we have the most up to date route from the config, not
                                          // an out of date object.
                                          route = latestState.routes.find(function (d) {
                                            return d.path === routePath;
                                          });
                                          _context3.prev = 1;

                                          if (route) {
                                            _context3.next = 6;
                                            break;
                                          }

                                          err = new Error("Route could not be found for: ".concat(routePath, "\n\nIf you removed this route, disregard this error.\nIf this is a dynamic route, consider adding it to the prefetchExcludes list:\n\n  addPrefetchExcludes(['").concat(routePath, "'])\n"));
                                          delete err.stack;
                                          throw err;

                                        case 6:
                                          _context3.next = 8;
                                          return (0, _getRouteData["default"])(route, latestState);

                                        case 8:
                                          route = _context3.sent;
                                          // Don't use any hashProp, just pass all the data in dev
                                          res.json(route);
                                          _context3.next = 16;
                                          break;

                                        case 12:
                                          _context3.prev = 12;
                                          _context3.t0 = _context3["catch"](1);
                                          res.status(404);
                                          next(_context3.t0);

                                        case 16:
                                        case "end":
                                          return _context3.stop();
                                      }
                                    }
                                  }, _callee3, null, [[1, 12]]);
                                }));

                                return function (_x7, _x8, _x9) {
                                  return _ref4.apply(this, arguments);
                                };
                              }());
                            });
                            return _context4.abrupt("return", new Promise(function (resolve) {
                              return setTimeout(resolve, 1);
                            }));

                          case 6:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function buildDevRoutes(_x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                buildDevRoutes(state);

                if (state.config.devServer && state.config.devServer.before) {
                  state.config.devServer.before(app);
                }

                return app;
              }
            });
            first = true;
            startedAt = Date.now();
            skipLog = false;
            console.log('Bundling Application...');
            (0, _utils.time)(_chalk["default"].green("[\u2713] Application Bundled"));
            devCompiler.hooks.invalid.tap({
              name: 'React-Static'
            }, function (file, changed) {
              // If a file is changed within the first two seconds of
              // the server starting, we don't bark about it. Less
              // noise is better!
              skipLog = changed - startedAt < 2000;

              if (!skipLog) {
                console.log('File changed:', file.replace(state.config.paths.ROOT, ''));
                console.log('Updating bundle...');
                (0, _utils.time)(_chalk["default"].green("[\u2713] Bundle Updated"));
              }
            });
            devCompiler.hooks.done.tap({
              name: 'React-Static'
            }, function (stats) {
              var messages = stats.toJson({}, true);
              var isSuccessful = !messages.errors.length;
              var hasWarnings = messages.warnings.length;

              if (isSuccessful && !skipLog) {
                if (first) {
                  // Print out any dev compiler warnings
                  if (hasWarnings) {
                    console.log(_chalk["default"].yellowBright("\n[!] There were ".concat(messages.warnings.length, " warnings during compilation\n")));
                    messages.warnings.forEach(function (message, index) {
                      console.warn("[warning ".concat(index, "]: ").concat(message, "\n"));
                    });
                  }

                  (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Application Bundled"));
                  var protocol = state.config.devServer.https ? 'https' : 'http';
                  console.log("".concat(_chalk["default"].green("[\u2713] App serving at"), " ").concat(_chalk["default"].blue("".concat(protocol, "://").concat(state.config.devServer.host, ":").concat(state.config.devServer.port))));
                } else {
                  (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Bundle Updated"));
                }
              } else if (!skipLog) {
                console.log(_chalk["default"].redBright("[\u274C] Application bundling failed"));
                console.error(_chalk["default"].redBright(messages.errors.join('\n')));
                console.warn(_chalk["default"].yellowBright(messages.warnings.join('\n')));
              }

              first = false;
            }); // Start the webpack dev server

            devServer = new _webpackDevServer["default"](devCompiler, devServerConfig); // Start the messages socket

            socket = (0, _socket["default"])();
            reloadClientData.current =
            /*#__PURE__*/
            (0, _asyncToGenerator2["default"])(
            /*#__PURE__*/
            _regenerator["default"].mark(function _callee5() {
              return _regenerator["default"].wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return (0, _fetchSiteData["default"])(latestState);

                    case 2:
                      latestState = _context5.sent;
                      socket.emit('message', {
                        type: 'reloadClientData'
                      });

                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));
            _context6.next = 27;
            return new Promise(function (resolve, reject) {
              devServer.listen(port, null, function (err) {
                if (err) {
                  console.error("Listening on ".concat(port, " failed: ").concat(err));
                  return reject(err);
                }

                resolve();
              });
            });

          case 27:
            // Make sure we start listening on the message port after the dev server.
            // We do this mostly to appease codesandbox.io, since they autobind to the first
            // port that opens up for their preview window.
            socket.listen(messagePort);
            console.log('Running plugins...');
            _context6.next = 31;
            return _plugins["default"].afterDevServerStart(state);

          case 31:
            state = _context6.sent;
            return _context6.abrupt("return", state);

          case 33:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _runExpressServer.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdGF0aWMvd2VicGFjay9ydW5EZXZTZXJ2ZXIuanMiXSwibmFtZXMiOlsiZGV2U2VydmVyIiwibGF0ZXN0U3RhdGUiLCJidWlsZERldlJvdXRlcyIsInJlbG9hZENsaWVudERhdGEiLCJjdXJyZW50IiwicnVuRGV2U2VydmVyIiwic3RhdGUiLCJydW5FeHByZXNzU2VydmVyIiwiaW50ZW5kZWRQb3J0IiwiTnVtYmVyIiwiY29uZmlnIiwicG9ydCIsImRlZmF1bHRNZXNzYWdlUG9ydCIsInByb2Nlc3MiLCJlbnYiLCJSRUFDVF9TVEFUSUNfTUVTU0FHRV9TT0NLRVRfUE9SVCIsIm1lc3NhZ2VQb3J0IiwibWVzc2FnZUhvc3QiLCJSRUFDVF9TVEFUSUNfTUVTU0FHRV9TT0NLRVRfSE9TVCIsImNvbnNvbGUiLCJsb2ciLCJjaGFsayIsInJlZCIsImdyZWVuIiwiZGV2Q29uZmlnIiwiZGV2Q29tcGlsZXIiLCJkZXZTZXJ2ZXJDb25maWciLCJjb250ZW50QmFzZSIsInBhdGhzIiwiUFVCTElDIiwiRElTVCIsInB1YmxpY1BhdGgiLCJoaXN0b3J5QXBpRmFsbGJhY2siLCJjb21wcmVzcyIsImNsaWVudExvZ0xldmVsIiwib3ZlcmxheSIsInN0YXRzIiwibm9JbmZvIiwiaG90T25seSIsInByb3h5IiwidGFyZ2V0Iiwid3MiLCJ3YXRjaE9wdGlvbnMiLCJpZ25vcmVkIiwiYmVmb3JlIiwiYXBwIiwibmV3U3RhdGUiLCJnZXQiLCJyZXEiLCJyZXMiLCJuZXh0Iiwic2VuZCIsInNpdGVEYXRhIiwiZXJyIiwic3RhdHVzIiwicm91dGVzIiwiZm9yRWFjaCIsInJvdXRlUGF0aCIsInBhdGgiLCJlbmNvZGVVUkkiLCJyb3V0ZSIsImZpbmQiLCJkIiwiRXJyb3IiLCJzdGFjayIsImpzb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmaXJzdCIsInN0YXJ0ZWRBdCIsIkRhdGUiLCJub3ciLCJza2lwTG9nIiwiaG9va3MiLCJpbnZhbGlkIiwidGFwIiwibmFtZSIsImZpbGUiLCJjaGFuZ2VkIiwicmVwbGFjZSIsIlJPT1QiLCJkb25lIiwibWVzc2FnZXMiLCJ0b0pzb24iLCJpc1N1Y2Nlc3NmdWwiLCJlcnJvcnMiLCJsZW5ndGgiLCJoYXNXYXJuaW5ncyIsIndhcm5pbmdzIiwieWVsbG93QnJpZ2h0IiwibWVzc2FnZSIsImluZGV4Iiwid2FybiIsInByb3RvY29sIiwiaHR0cHMiLCJibHVlIiwiaG9zdCIsInJlZEJyaWdodCIsImVycm9yIiwiam9pbiIsIldlYnBhY2tEZXZTZXJ2ZXIiLCJzb2NrZXQiLCJlbWl0IiwidHlwZSIsInJlamVjdCIsImxpc3RlbiIsInBsdWdpbnMiLCJhZnRlckRldlNlcnZlclN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBSUEsU0FBSjtBQUNBLElBQUlDLFdBQUo7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHLDBCQUFNLENBQUUsQ0FBN0I7O0FBRU8sSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixHQUFNO0FBQ3BDLE1BQUlBLGdCQUFnQixDQUFDQyxPQUFyQixFQUE4QjtBQUM1QkQsSUFBQUEsZ0JBQWdCLENBQUNDLE9BQWpCO0FBQ0Q7QUFDRixDQUpNLEMsQ0FNUDs7Ozs7U0FDOEJDLFk7Ozs7Ozs7K0JBQWYsaUJBQTRCQyxLQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBT1ROLFNBUFM7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxtQkFRTEUsY0FBYyxDQUFDSSxLQUFELENBUlQ7O0FBQUE7QUFBQTtBQUFBLG1CQVNMSCxnQkFBZ0IsRUFUWDs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLG1CQVdHSSxnQkFBZ0IsQ0FBQ0QsS0FBRCxDQVhuQjs7QUFBQTtBQVdYQSxZQUFBQSxLQVhXOztBQUFBO0FBQUEsNkNBY05BLEtBZE07O0FB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VUFBQTBDLEdBQUcsRUFBSTtBQUNsQyxvQkFBSUEsR0FBSixFQUFTO0FBQ1BsQyxrQkFBQUEsT0FBTyxDQUFDZ0YsS0FBUix3QkFBOEJ4RixJQUE5QixzQkFBOEMwQyxHQUE5QztBQUNBLHlCQUFPb0QsTUFBTSxDQUFDcEQsR0FBRCxDQUFiO0FBQ0Q7O0FBQ0RjLGdCQUFBQSxPQUFPO0FBQ1IsZUFORDtBQU9ELGFBUkssQ0FyTlI7O0FBQUE7QUErTkU7QUFDQTtBQUNBO0FBQ0FtQyxZQUFBQSxNQUFNLENBQUNJLE1BQVAsQ0FBYzFGLFdBQWQ7QUFFQUcsWUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVksb0JBQVo7QUFwT0Y7QUFBQSxtQkFxT2dCdUYsb0JBQVFDLG1CQUFSLENBQTRCdEcsS0FBNUIsQ0FyT2hCOztBQUFBO0FBcU9FQSxZQUFBQSxLQXJPRjtBQUFBLDhDQXVPU0EsS0F2T1Q7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmUsIHJlYWN0L25vLWRhbmdlciwgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xuaW1wb3J0IHdlYnBhY2sgZnJvbSAnd2VicGFjaydcbmltcG9ydCBjaGFsayBmcm9tICdjaGFsaydcbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8nXG5pbXBvcnQgV2VicGFja0RldlNlcnZlciBmcm9tICd3ZWJwYWNrLWRldi1zZXJ2ZXInXG4vL1xuaW1wb3J0IG1ha2VXZWJwYWNrQ29uZmlnIGZyb20gJy4vbWFrZVdlYnBhY2tDb25maWcnXG5pbXBvcnQgZ2V0Um91dGVEYXRhIGZyb20gJy4uL2dldFJvdXRlRGF0YSdcbmltcG9ydCBwbHVnaW5zIGZyb20gJy4uL3BsdWdpbnMnXG5pbXBvcnQgeyBmaW5kQXZhaWxhYmxlUG9ydCwgdGltZSwgdGltZUVuZCB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IGZldGNoU2l0ZURhdGEgZnJvbSAnLi4vZmV0Y2hTaXRlRGF0YSdcblxubGV0IGRldlNlcnZlclxubGV0IGxhdGVzdFN0YXRlXG5sZXQgYnVpbGREZXZSb3V0ZXMgPSAoKSA9PiB7fVxuXG5leHBvcnQgY29uc3QgcmVsb2FkQ2xpZW50RGF0YSA9ICgpID0+IHtcbiAgaWYgKHJlbG9hZENsaWVudERhdGEuY3VycmVudCkge1xuICAgIHJlbG9hZENsaWVudERhdGEuY3VycmVudCgpXG4gIH1cbn1cblxuLy8gU3RhcnRzIHRoZSBkZXZlbG9wbWVudCBzZXJ2ZXJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHJ1bkRldlNlcnZlcihzdGF0ZSkge1xuICAvLyBUT0RPIGNoZWNrIGNvbmZpZy5kZXZTZXJ2ZXIgZm9yIGNoYW5nZXMgYW5kIG5vdGlmeSB1c2VyXG4gIC8vIGlmIHRoZSBzZXJ2ZXIgbmVlZHMgdG8gYmUgcmVzdGFydGVkIGZvciBjaGFuZ2VzIHRvIHRha2VcbiAgLy8gZWZmZWN0LlxuXG4gIC8vIElmIHRoZSBzZXJ2ZXIgaXMgYWxyZWFkeSBydW5uaW5nLCB0cmlnZ2VyIGEgcmVmcmVzaCB0byB0aGUgY2xpZW50XG5cbiAgaWYgKGRldlNlcnZlcikge1xuICAgIGF3YWl0IGJ1aWxkRGV2Um91dGVzKHN0YXRlKVxuICAgIGF3YWl0IHJlbG9hZENsaWVudERhdGEoKVxuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gYXdhaXQgcnVuRXhwcmVzc1NlcnZlcihzdGF0ZSlcbiAgfVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG5hc3luYyBmdW5jdGlvbiBydW5FeHByZXNzU2VydmVyKHN0YXRlKSB7XG4gIC8vIERlZmF1bHQgdG8gbG9jYWxob3N0OjMwMDAsIG9yIHVzZSBhIGN1c3RvbSBjb21ibyBpZiBkZWZpbmVkIGluIHN0YXRpYy5jb25maWcuanNcbiAgLy8gb3IgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gIGNvbnN0IGludGVuZGVkUG9ydCA9IE51bWJlcihzdGF0ZS5jb25maWcuZGV2U2VydmVyLnBvcnQpXG4gIGNvbnN0IHBvcnQgPSBhd2FpdCBmaW5kQXZhaWxhYmxlUG9ydChpbnRlbmRlZFBvcnQpXG5cbiAgbGV0IGRlZmF1bHRNZXNzYWdlUG9ydCA9IDQwMDA7XG5cbiAgaWYocHJvY2Vzcy5lbnYuUkVBQ1RfU1RBVElDX01FU1NBR0VfU09DS0VUX1BPUlQpe1xuICAgIGRlZmF1bHRNZXNzYWdlUG9ydCA9IHByb2Nlc3MuZW52LlJFQUNUX1NUQVRJQ19NRVNTQUdFX1NPQ0tFVF9QT1JUO1xuICB9XG4gIC8vIEZpbmQgYW4gYXZhaWxhYmxlIHBvcnQgZm9yIG1lc3NhZ2VzLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoZSBkZXZTZXJ2ZXIgcG9ydFxuICBjb25zdCBtZXNzYWdlUG9ydCA9IGF3YWl0IGZpbmRBdmFpbGFibGVQb3J0KGRlZmF1bHRNZXNzYWdlUG9ydCwgW3BvcnRdKVxuXG4gIGNvbnN0IG1lc3NhZ2VIb3N0ID1cbiAgICBwcm9jZXNzLmVudi5SRUFDVF9TVEFUSUNfTUVTU0FHRV9TT0NLRVRfSE9TVCB8fCAnaHR0cDovL2xvY2FsaG9zdCdcblxuICBpZiAoaW50ZW5kZWRQb3J0ICE9PSBwb3J0KSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBjaGFsay5yZWQoXG4gICAgICAgIGBXYXJuaW5nISBQb3J0ICR7aW50ZW5kZWRQb3J0fSBpcyBub3QgYXZhaWxhYmxlLiBVc2luZyBwb3J0ICR7Y2hhbGsuZ3JlZW4oXG4gICAgICAgICAgcG9ydFxuICAgICAgICApfSBpbnN0ZWFkIWBcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBzdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjb25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmNvbmZpZyxcbiAgICAgIGRldlNlcnZlcjoge1xuICAgICAgICAuLi5zdGF0ZS5jb25maWcuZGV2U2VydmVyLFxuICAgICAgICBwb3J0LFxuICAgICAgfSxcbiAgICB9LFxuICB9XG5cbiAgY29uc3QgZGV2Q29uZmlnID0gbWFrZVdlYnBhY2tDb25maWcoc3RhdGUpXG4gIGNvbnN0IGRldkNvbXBpbGVyID0gd2VicGFjayhkZXZDb25maWcpXG5cbiAgY29uc3QgZGV2U2VydmVyQ29uZmlnID0ge1xuICAgIGNvbnRlbnRCYXNlOiBbc3RhdGUuY29uZmlnLnBhdGhzLlBVQkxJQywgc3RhdGUuY29uZmlnLnBhdGhzLkRJU1RdLFxuICAgIHB1YmxpY1BhdGg6ICcvJyxcbiAgICBoaXN0b3J5QXBpRmFsbGJhY2s6IHRydWUsXG4gICAgY29tcHJlc3M6IGZhbHNlLFxuICAgIGNsaWVudExvZ0xldmVsOiAnd2FybmluZycsXG4gICAgb3ZlcmxheTogdHJ1ZSxcbiAgICBzdGF0czogJ2Vycm9ycy1vbmx5JyxcbiAgICBub0luZm86IHRydWUsXG4gICAgLi4uc3RhdGUuY29uZmlnLmRldlNlcnZlcixcbiAgICBob3RPbmx5OiB0cnVlLFxuICAgIHByb3h5OiB7XG4gICAgICAnL3NvY2tldC5pbyc6IHtcbiAgICAgICAgdGFyZ2V0OiBgJHttZXNzYWdlSG9zdH06JHttZXNzYWdlUG9ydH1gLFxuICAgICAgICB3czogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICAuLi4oc3RhdGUuY29uZmlnLmRldlNlcnZlciA/IHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIucHJveHkgfHwge30gOiB7fSksXG4gICAgfSxcbiAgICB3YXRjaE9wdGlvbnM6IHtcbiAgICAgIC4uLihzdGF0ZS5jb25maWcuZGV2U2VydmVyXG4gICAgICAgID8gc3RhdGUuY29uZmlnLmRldlNlcnZlci53YXRjaE9wdGlvbnMgfHwge31cbiAgICAgICAgOiB7fSksXG4gICAgICBpZ25vcmVkOiBbXG4gICAgICAgIC9ub2RlX21vZHVsZXMvLFxuXG4gICAgICAgIC4uLigoc3RhdGUuY29uZmlnLmRldlNlcnZlci53YXRjaE9wdGlvbnMgfHwge30pLmlnbm9yZWQgfHwgW10pLFxuICAgICAgXSxcbiAgICB9LFxuICAgIGJlZm9yZTogYXBwID0+IHtcbiAgICAgIC8vIFNpbmNlIHJvdXRlcyBtYXkgY2hhbmdlIGR1cmluZyBkZXYsIHRoaXMgZnVuY3Rpb24gY2FuIHJlYnVpbGQgYWxsIG9mIHRoZSBjb25maWdcbiAgICAgIC8vIHJvdXRlcy4gSXQgYWxzbyByZWZlcmVuY2VzIHRoZSBvcmlnaW5hbCBjb25maWcgd2hlbiBwb3NzaWJsZSwgdG8gbWFrZSBzdXJlIGl0XG4gICAgICAvLyB1c2VzIGFueSB1cCB0byBkYXRlIGdldERhdGEgY2FsbGJhY2sgZ2VuZXJhdGVkIGZyb20gbmV3IG9yIHJlcGxhY2VtZW50IHJvdXRlcy5cbiAgICAgIGJ1aWxkRGV2Um91dGVzID0gYXN5bmMgbmV3U3RhdGUgPT4ge1xuICAgICAgICBsYXRlc3RTdGF0ZSA9IGF3YWl0IGZldGNoU2l0ZURhdGEobmV3U3RhdGUpXG5cbiAgICAgICAgYXBwLmdldCgnL19fcmVhY3Qtc3RhdGljX18vc2l0ZURhdGEnLCBhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzLnNlbmQobGF0ZXN0U3RhdGUuc2l0ZURhdGEpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXMuc3RhdHVzKDUwMClcbiAgICAgICAgICAgIHJlcy5zZW5kKGVycilcbiAgICAgICAgICAgIG5leHQoZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBTZXJ2ZSBlYWNoIHJvdXRlcyBkYXRhXG4gICAgICAgIGxhdGVzdFN0YXRlLnJvdXRlcy5mb3JFYWNoKCh7IHBhdGg6IHJvdXRlUGF0aCB9KSA9PiB7XG4gICAgICAgICAgYXBwLmdldChcbiAgICAgICAgICAgIGAvX19yZWFjdC1zdGF0aWNfXy9yb3V0ZUluZm8vJHtlbmNvZGVVUkkoXG4gICAgICAgICAgICAgIHJvdXRlUGF0aCA9PT0gJy8nID8gJycgOiByb3V0ZVBhdGhcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgIGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSB0aGUgbW9zdCB1cCB0byBkYXRlIHJvdXRlIGZyb20gdGhlIGNvbmZpZywgbm90XG4gICAgICAgICAgICAgIC8vIGFuIG91dCBvZiBkYXRlIG9iamVjdC5cbiAgICAgICAgICAgICAgbGV0IHJvdXRlID0gbGF0ZXN0U3RhdGUucm91dGVzLmZpbmQoZCA9PiBkLnBhdGggPT09IHJvdXRlUGF0aClcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBSb3V0ZSBjb3VsZCBub3QgYmUgZm91bmQgZm9yOiAke3JvdXRlUGF0aH1cblxuSWYgeW91IHJlbW92ZWQgdGhpcyByb3V0ZSwgZGlzcmVnYXJkIHRoaXMgZXJyb3IuXG5JZiB0aGlzIGlzIGEgZHluYW1pYyByb3V0ZSwgY29uc2lkZXIgYWRkaW5nIGl0IHRvIHRoZSBwcmVmZXRjaEV4Y2x1ZGVzIGxpc3Q6XG5cbiAgYWRkUHJlZmV0Y2hFeGNsdWRlcyhbJyR7cm91dGVQYXRofSddKVxuYFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgZGVsZXRlIGVyci5zdGFja1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm91dGUgPSBhd2FpdCBnZXRSb3V0ZURhdGEocm91dGUsIGxhdGVzdFN0YXRlKVxuXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIGFueSBoYXNoUHJvcCwganVzdCBwYXNzIGFsbCB0aGUgZGF0YSBpbiBkZXZcbiAgICAgICAgICAgICAgICByZXMuanNvbihyb3V0ZSlcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cyg0MDQpXG4gICAgICAgICAgICAgICAgbmV4dChlcnIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpXG4gICAgICB9XG5cbiAgICAgIGJ1aWxkRGV2Um91dGVzKHN0YXRlKVxuXG4gICAgICBpZiAoc3RhdGUuY29uZmlnLmRldlNlcnZlciAmJiBzdGF0ZS5jb25maWcuZGV2U2VydmVyLmJlZm9yZSkge1xuICAgICAgICBzdGF0ZS5jb25maWcuZGV2U2VydmVyLmJlZm9yZShhcHApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcHBcbiAgICB9LFxuICB9XG5cbiAgbGV0IGZpcnN0ID0gdHJ1ZVxuICBjb25zdCBzdGFydGVkQXQgPSBEYXRlLm5vdygpXG4gIGxldCBza2lwTG9nID0gZmFsc2VcblxuICBjb25zb2xlLmxvZygnQnVuZGxpbmcgQXBwbGljYXRpb24uLi4nKVxuICB0aW1lKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gQXBwbGljYXRpb24gQnVuZGxlZCcpKVxuXG4gIGRldkNvbXBpbGVyLmhvb2tzLmludmFsaWQudGFwKFxuICAgIHtcbiAgICAgIG5hbWU6ICdSZWFjdC1TdGF0aWMnLFxuICAgIH0sXG4gICAgKGZpbGUsIGNoYW5nZWQpID0+IHtcbiAgICAgIC8vIElmIGEgZmlsZSBpcyBjaGFuZ2VkIHdpdGhpbiB0aGUgZmlyc3QgdHdvIHNlY29uZHMgb2ZcbiAgICAgIC8vIHRoZSBzZXJ2ZXIgc3RhcnRpbmcsIHdlIGRvbid0IGJhcmsgYWJvdXQgaXQuIExlc3NcbiAgICAgIC8vIG5vaXNlIGlzIGJldHRlciFcbiAgICAgIHNraXBMb2cgPSBjaGFuZ2VkIC0gc3RhcnRlZEF0IDwgMjAwMFxuICAgICAgaWYgKCFza2lwTG9nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIGNoYW5nZWQ6JywgZmlsZS5yZXBsYWNlKHN0YXRlLmNvbmZpZy5wYXRocy5ST09ULCAnJykpXG4gICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBidW5kbGUuLi4nKVxuICAgICAgICB0aW1lKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gQnVuZGxlIFVwZGF0ZWQnKSlcbiAgICAgIH1cbiAgICB9XG4gIClcblxuICBkZXZDb21waWxlci5ob29rcy5kb25lLnRhcChcbiAgICB7XG4gICAgICBuYW1lOiAnUmVhY3QtU3RhdGljJyxcbiAgICB9LFxuICAgIHN0YXRzID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gc3RhdHMudG9Kc29uKHt9LCB0cnVlKVxuICAgICAgY29uc3QgaXNTdWNjZXNzZnVsID0gIW1lc3NhZ2VzLmVycm9ycy5sZW5ndGhcbiAgICAgIGNvbnN0IGhhc1dhcm5pbmdzID0gbWVzc2FnZXMud2FybmluZ3MubGVuZ3RoXG5cbiAgICAgIGlmIChpc1N1Y2Nlc3NmdWwgJiYgIXNraXBMb2cpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgLy8gUHJpbnQgb3V0IGFueSBkZXYgY29tcGlsZXIgd2FybmluZ3NcbiAgICAgICAgICBpZiAoaGFzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBjaGFsay55ZWxsb3dCcmlnaHQoXG4gICAgICAgICAgICAgICAgYFxcbltcXHUwMDIxXSBUaGVyZSB3ZXJlICR7bWVzc2FnZXMud2FybmluZ3MubGVuZ3RofSB3YXJuaW5ncyBkdXJpbmcgY29tcGlsYXRpb25cXG5gXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIG1lc3NhZ2VzLndhcm5pbmdzLmZvckVhY2goKG1lc3NhZ2UsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3dhcm5pbmcgJHtpbmRleH1dOiAke21lc3NhZ2V9XFxuYClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZUVuZChjaGFsay5ncmVlbignW1xcdTI3MTNdIEFwcGxpY2F0aW9uIEJ1bmRsZWQnKSlcbiAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IHN0YXRlLmNvbmZpZy5kZXZTZXJ2ZXIuaHR0cHMgPyAnaHR0cHMnIDogJ2h0dHAnXG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgJHtjaGFsay5ncmVlbignW1xcdTI3MTNdIEFwcCBzZXJ2aW5nIGF0Jyl9ICR7Y2hhbGsuYmx1ZShcbiAgICAgICAgICAgICAgYCR7cHJvdG9jb2x9Oi8vJHtzdGF0ZS5jb25maWcuZGV2U2VydmVyLmhvc3R9OiR7c3RhdGUuY29uZmlnLmRldlNlcnZlci5wb3J0fWBcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lRW5kKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gQnVuZGxlIFVwZGF0ZWQnKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2tpcExvZykge1xuICAgICAgICBjb25zb2xlLmxvZyhjaGFsay5yZWRCcmlnaHQoJ1tcXHUyNzRDXSBBcHBsaWNhdGlvbiBidW5kbGluZyBmYWlsZWQnKSlcbiAgICAgICAgY29uc29sZS5lcnJvcihjaGFsay5yZWRCcmlnaHQobWVzc2FnZXMuZXJyb3JzLmpvaW4oJ1xcbicpKSlcbiAgICAgICAgY29uc29sZS53YXJuKGNoYWxrLnllbGxvd0JyaWdodChtZXNzYWdlcy53YXJuaW5ncy5qb2luKCdcXG4nKSkpXG4gICAgICB9XG5cbiAgICAgIGZpcnN0ID0gZmFsc2VcbiAgICB9XG4gIClcblxuICAvLyBTdGFydCB0aGUgd2VicGFjayBkZXYgc2VydmVyXG4gIGRldlNlcnZlciA9IG5ldyBXZWJwYWNrRGV2U2VydmVyKGRldkNvbXBpbGVyLCBkZXZTZXJ2ZXJDb25maWcpXG5cbiAgLy8gU3RhcnQgdGhlIG1lc3NhZ2VzIHNvY2tldFxuICBjb25zdCBzb2NrZXQgPSBpbygpXG5cbiAgcmVsb2FkQ2xpZW50RGF0YS5jdXJyZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgIGxhdGVzdFN0YXRlID0gYXdhaXQgZmV0Y2hTaXRlRGF0YShsYXRlc3RTdGF0ZSlcbiAgICBzb2NrZXQuZW1pdCgnbWVzc2FnZScsIHsgdHlwZTogJ3JlbG9hZENsaWVudERhdGEnIH0pXG4gIH1cblxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGV2U2VydmVyLmxpc3Rlbihwb3J0LCBudWxsLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBMaXN0ZW5pbmcgb24gJHtwb3J0fSBmYWlsZWQ6ICR7ZXJyfWApXG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcblxuICAvLyBNYWtlIHN1cmUgd2Ugc3RhcnQgbGlzdGVuaW5nIG9uIHRoZSBtZXNzYWdlIHBvcnQgYWZ0ZXIgdGhlIGRldiBzZXJ2ZXIuXG4gIC8vIFdlIGRvIHRoaXMgbW9zdGx5IHRvIGFwcGVhc2UgY29kZXNhbmRib3guaW8sIHNpbmNlIHRoZXkgYXV0b2JpbmQgdG8gdGhlIGZpcnN0XG4gIC8vIHBvcnQgdGhhdCBvcGVucyB1cCBmb3IgdGhlaXIgcHJldmlldyB3aW5kb3cuXG4gIHNvY2tldC5saXN0ZW4obWVzc2FnZVBvcnQpXG5cbiAgY29uc29sZS5sb2coJ1J1bm5pbmcgcGx1Z2lucy4uLicpXG4gIHN0YXRlID0gYXdhaXQgcGx1Z2lucy5hZnRlckRldlNlcnZlclN0YXJ0KHN0YXRlKVxuXG4gIHJldHVybiBzdGF0ZVxufVxuIl19